<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        let [a, b, c] = [1, 2, 3]
        console.log(a, b, c);
        //嵌套结构
        let [foo1, foo2, foo3, [bar1, bar2, [baz]]] = [1, 2, 3, [1, 3, [4]]]
        console.log(foo1, foo2, foo3, bar1, bar2, baz);

        // 忽略跳过
        let [, , third] = ['foo', 'bar', 'baz']
        console.log(third)

        let obj = {
            name: 'lv',
            age: 18,
            meta: {
                disable: true
            }
        }

        let { name, meta: { disable } } = obj
        console.log(name, disable);

        // one模式匹配第一个 ， other将其他的结构为一个数组
        let arr = [1, 2, 3, 4]
        let [one, ...other] = arr
        console.log(one, other)

        // 结构如果失败了这个就是undefined
        let obj1 = { on: 'w123123', attr: 'src' }
        const { on, scene, ...fail } = obj1
        console.log(on, fail, scene);

        // 一下都是错误测试 报错 等号的右边不是数组或者可遍历的结构就会报错
        // 准确的说是因为这种的数据结构不具备迭代器  Iterator 
        // let [footest] = 1;
        // let [footest] = false;
        // let [footest] = NaN;
        // let [footest] = undefined;
        // let [footest] = null;
        // let [footest] = {};

        // 结构可以指定默认值
        let [params = 1] = []
        console.log(params);

        // 只有在结构出来的直严格等于undefined的时候才会用默认值
        let [x, y = 'y'] = ['x', undefined]
        console.log(x, y);

        // 只有在结构出来的直严格等于undefined的时候才会用默认值 加下例

        let [test, test1 = '默认值不会启用'] = [1, null]
        // 以为null不严格等于undefined所以结构的值是null
        console.log(test, test1); // 1,null

        // 如果结构的默认值是一个表达式的话那么只有在默认值生效是表达式才会执行
        // 也就是说如果结构成功了那么默认值就不会使用函数表达式就不会执行
        function f() {
            return '只有默认生效了我才会执行'
        }
        let [fnTest = f()] = [];
        console.log(fnTest);

        // 默认值可以使用结构赋值的其他变量
        let [last = 1, first = last] = []
        console.log(last, first);

        // 声明前使用 暂时性死区
        let [last1 = first1, first1 = 1] = [];
        console.log(last1,first1);
    </script>
</body>

</html>